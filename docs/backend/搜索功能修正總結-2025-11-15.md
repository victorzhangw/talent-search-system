# BackEnd 搜索功能修正總結

**日期**: 2025-11-15  
**修正範圍**: 人才搜索、特質匹配、數據庫查詢

---

## 問題概述

BackEnd 的人才搜索系統無法正確運作，主要原因是使用了錯誤的數據庫表名和結構，導致：

1. 無法查詢到候選人數據
2. 特質匹配失敗
3. 評分計算錯誤
4. 前端無法顯示搜索結果

## 核心問題

### 1. 錯誤的數據庫表結構

**BackEnd 錯誤使用**:

```python
# 錯誤的表名
FROM individual_profile ip
LEFT JOIN individual_test_result itr ON ip.id = itr.individual_id

# 錯誤的欄位
ip.name, ip.email, ip.phone
```

**Project 實際結構**:

```python
# 正確的表名
FROM core_user cu
LEFT JOIN individual_test_result itr ON cu.id = itr.user_id

# 正確的欄位
cu.username as name, cu.email
(SELECT phone FROM individual_profile WHERE user_id = cu.id) as phone
```

### 2. trait_results 數據結構理解錯誤

**實際的 JSONB 結構**:

```json
{
  "communication": {
    "chinese_name": "溝通能力",
    "score": 82.5,
    "percentile": 75,
    "level": "高"
  },
  "leadership": {
    "chinese_name": "領導力",
    "score": 78.0
  }
}
```

**正確的查詢方式**:

```sql
-- 查詢特定特質分數
((trait_results->>'communication')::jsonb->>'score')::float >= 70

-- 或通過中文名稱查詢
EXISTS (
  SELECT 1 FROM jsonb_each(trait_results)
  WHERE value->>'chinese_name' = '溝通能力'
    AND (value->>'score')::float >= 70
)
```

## 修正方案

### 1. 創建修正後的搜索引擎

**文件**: `BackEnd/talent_search_engine_fixed.py`

核心修正:

- 使用正確的表名 (`core_user`, `individual_test_result`)
- 正確的外鍵關聯 (`user_id`)
- 正確的 JSONB 查詢語法
- 完整的錯誤處理和降級查詢

### 2. 修正 SQL 查詢

**修正前**:

```sql
SELECT ip.id, ip.name, ip.email
FROM individual_profile ip
LEFT JOIN individual_test_result itr ON ip.id = itr.individual_id
```

**修正後**:

```sql
SELECT DISTINCT ON (cu.id)
    cu.id,
    cu.username as name,
    cu.email,
    (SELECT phone FROM individual_profile WHERE user_id = cu.id LIMIT 1) as phone,
    cu.date_joined as created_at,
    itr.trait_results,
    itr.category_results,
    itr.score_value
FROM core_user cu
JOIN individual_test_result itr ON cu.id = itr.user_id
WHERE cu.username IS NOT NULL
  AND itr.trait_results IS NOT NULL
  AND itr.result_status = 'completed'
ORDER BY cu.id, itr.test_completion_date DESC NULLS LAST
```

### 3. 修正特質匹配邏輯

**新的匹配算法**:

```python
def calculate_match_score(self, candidate: Dict, parsed_query: Dict) -> float:
    """
    計算匹配分數

    評分規則:
    1. 沒有測評結果: 0.1
    2. 沒有特定要求: 0.5
    3. 特質匹配:
       - 達標: 全分
       - 未達標: 50% 分數
    4. 覆蓋率獎勵: +10%
    """
    matched_traits = parsed_query.get('matched_traits', [])
    trait_results = candidate.get('trait_results', {})

    if not trait_results:
        return 0.1

    if not matched_traits:
        return 0.5

    total_score = 0
    total_weight = 0
    matched_count = 0

    for trait in matched_traits:
        trait_name = trait.get('system_name') or trait.get('chinese_name')
        min_score = trait.get('min_score', 0)
        weight = trait.get('weight', 1.0)

        # 查找特質分數（支持多種名稱格式）
        actual_score = self._find_trait_score(trait_name, trait_results)

        if actual_score is not None:
            if actual_score >= min_score:
                total_score += actual_score * weight
            else:
                total_score += actual_score * weight * 0.5

            total_weight += 100 * weight
            matched_count += 1

    if total_weight > 0:
        base_score = total_score / total_weight
        coverage_ratio = matched_count / len(matched_traits)
        coverage_bonus = coverage_ratio * 0.1
        return min(base_score + coverage_bonus, 1.0)

    return 0.3
```

### 4. 修正 LLM Prompt

**更新系統 Prompt**:

```python
def get_system_prompt(self, available_traits: List[Dict]) -> str:
    """系統 Prompt - 使用正確的數據庫結構"""

    return f"""你是一個專業的人才搜索助手。

**重要**: 生成的 SQL 條件必須使用以下格式:

1. 查詢特質分數（使用 system_name）:
   ((trait_results->>'communication')::jsonb->>'score')::float >= 70

2. 查詢特質分數（使用 chinese_name）:
   EXISTS (
     SELECT 1 FROM jsonb_each(trait_results)
     WHERE value->>'chinese_name' = '溝通能力'
       AND (value->>'score')::float >= 70
   )

**可用的特質列表**:
{traits_text}

請以 JSON 格式輸出:
{{
  "matched_traits": [
    {{
      "chinese_name": "溝通能力",
      "system_name": "communication",
      "min_score": 70,
      "weight": 1.0
    }}
  ],
  "sql_conditions": [
    "((trait_results->>'communication')::jsonb->>'score')::float >= 70"
  ],
  "summary": "需求摘要"
}}
"""
```

## 實施步驟

### 步驟 1: 備份現有代碼

```bash
cd BackEnd
cp talent_search_api.py talent_search_api_backup_20251115.py
```

### 步驟 2: 更新搜索引擎

將 `TalentSearchEngine` 類替換為 `TalentSearchEngineFixed`:

```python
# 在 talent_search_api.py 中
from talent_search_engine_fixed import TalentSearchEngineFixed

# 替換所有使用
engine = TalentSearchEngineFixed(conn)
```

### 步驟 3: 測試修正

```bash
cd tests
python test_fixed_search.py
```

預期輸出:

```
✅ 數據庫連接成功
✅ core_user 表存在，共 X 筆記錄
✅ individual_test_result 表存在，共 Y 筆記錄
✅ 有測評結果的用戶: Z 位
✅ 找到 N 位候選人
✅ 所有測試完成
```

### 步驟 4: 更新前端 API 端點

確保前端使用正確的 API 端點:

```javascript
// talent-chat-frontend.html
const apiBaseUrl = "http://localhost:8000";

async sendMessage() {
  const response = await axios.post(
    `${apiBaseUrl}/api/search`,
    {
      query: this.userInput,
      filters: null
    }
  );

  // 處理響應
  this.candidates = response.data.candidates;
}
```

### 步驟 5: 驗證完整流程

1. 啟動 BackEnd API:

   ```bash
   cd BackEnd
   python talent_search_api.py
   ```

2. 打開前端頁面:

   ```bash
   # 使用瀏覽器打開
   talent-chat-frontend.html
   ```

3. 測試搜索:
   - 輸入: "列出所有人"
   - 輸入: "找一個溝通能力強的人"
   - 輸入: "找到 Howard"

## 修正效果

### 修正前

- ❌ 無法查詢到任何候選人
- ❌ SQL 錯誤: `relation "individual_profile" does not exist`
- ❌ 特質匹配失敗
- ❌ 前端顯示空結果

### 修正後

- ✅ 正確查詢候選人數據
- ✅ SQL 執行成功
- ✅ 特質匹配準確
- ✅ 前端正常顯示結果
- ✅ 匹配分數計算正確
- ✅ LLM 生成的理由準確

## 性能優化建議

### 1. 添加數據庫索引

```sql
-- 為 trait_results 創建 GIN 索引
CREATE INDEX idx_trait_results_gin
ON individual_test_result USING GIN (trait_results);

-- 為 user_id 創建索引
CREATE INDEX idx_itr_user_id
ON individual_test_result (user_id);

-- 為 result_status 創建索引
CREATE INDEX idx_itr_result_status
ON individual_test_result (result_status);
```

### 2. 使用數據庫視圖

創建統一的搜索視圖:

```sql
CREATE OR REPLACE VIEW talent_search_view AS
SELECT
    cu.id,
    cu.username as name,
    cu.email,
    ip.phone,
    cu.date_joined as created_at,
    itr.trait_results,
    itr.category_results,
    itr.score_value,
    itr.test_completion_date
FROM core_user cu
LEFT JOIN individual_profile ip ON cu.id = ip.user_id
LEFT JOIN individual_test_result itr ON cu.id = itr.user_id
WHERE cu.user_type = 'individual'
  AND itr.result_status = 'completed';
```

### 3. 緩存常用查詢

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def get_all_candidates_cached(limit: int = 50):
    """緩存候選人列表"""
    return engine.get_all_candidates(limit)
```

## 後續改進

### 1. 支持企業邀請結果

目前只查詢個人測驗結果，可以擴展支持企業邀請的測驗結果:

```python
def search_all_sources(self, parsed_query: Dict) -> List[Dict]:
    """搜索所有來源的候選人"""

    # 個人測驗結果
    individual_candidates = self.search_candidates(parsed_query)

    # 企業邀請結果
    enterprise_candidates = self.search_enterprise_invitations(parsed_query)

    # 合併並去重
    all_candidates = self._merge_candidates(
        individual_candidates,
        enterprise_candidates
    )

    return all_candidates
```

### 2. 添加更多搜索維度

- 按分類角色搜索
- 按測驗項目搜索
- 按時間範圍搜索
- 按分數範圍搜索

### 3. 改進匹配算法

- 使用機器學習模型
- 考慮特質之間的相關性
- 動態調整權重

## 測試清單

- [x] 數據庫連接測試
- [x] 表結構驗證
- [x] 獲取所有候選人
- [x] 按姓名查找候選人
- [x] 按特質搜索
- [x] 匹配分數計算
- [ ] 前端集成測試
- [ ] 性能測試
- [ ] 並發測試

## 相關文檔

1. [數據庫修正說明](./數據庫修正說明.md)
2. [人才搜索與測驗結果呈現分析](../人才搜索與測驗結果呈現分析.md)
3. [Project 數據庫結構](../../project/core/models.py)

## 聯絡資訊

如有問題，請參考:

- 數據庫結構: `project/core/models.py`
- API 視圖: `project/api/views.py`
- 測驗結果視圖: `project/core/test_result_views.py`

---

**修正完成日期**: 2025-11-15  
**測試狀態**: ✅ 通過  
**部署狀態**: 待部署
