# BackEnd 數據庫查詢修正說明

**日期**: 2025-11-15

## 問題分析

BackEnd 的搜索代碼使用了錯誤的數據庫表名和結構，導致無法正確搜索人才和測驗結果。

### 錯誤的表名和欄位

**BackEnd 使用的（錯誤）**:

```sql
-- 錯誤的表名
FROM individual_profile ip
LEFT JOIN individual_test_result itr ON ip.id = itr.individual_id

-- 錯誤的欄位
ip.name, ip.email, ip.phone
```

**Project 實際的（正確）**:

```sql
-- 正確的表名
FROM core_user cu
LEFT JOIN individual_test_result itr ON cu.id = itr.user_id

-- 正確的欄位
cu.username as name, cu.email
(SELECT phone FROM individual_profile WHERE user_id = cu.id) as phone
```

## 數據庫結構對比

### 1. 用戶表

**錯誤認知**:

- 表名: `individual_profile`
- 主鍵: `id`
- 欄位: `name`, `email`, `phone`

**實際結構**:

- 表名: `core_user` (主表)
- 主鍵: `id`
- 欄位: `username`, `email`, `user_type`
- 關聯表: `individual_profile` (一對一關係)
  - 外鍵: `user_id` → `core_user.id`
  - 欄位: `real_name`, `phone`, `birth_date`

### 2. 測驗結果表

**錯誤認知**:

```sql
individual_test_result
├── individual_id (外鍵)
├── test_date
├── result_data
└── project_id
```

**實際結構**:

```sql
individual_test_result
├── user_id (外鍵 → core_user.id)
├── test_project_id (外鍵 → test_project.id)
├── test_completion_date
├── raw_data (JSONB)
├── trait_results (JSONB)
├── category_results (JSONB)
├── score_value
└── result_status
```

### 3. 測驗邀請表

**BackEnd 未使用，但 Project 中存在**:

```sql
test_invitation
├── id
├── enterprise_id (外鍵 → core_user.id)
├── invitee_id (外鍵 → test_invitee.id)
├── test_project_id
├── status (pending/in_progress/completed)
├── invited_at
├── completed_at
└── testprojectresult (一對一關聯)
```

### 4. 企業測驗結果表

**Project 中的另一個結果表**:

```sql
test_project_result
├── id
├── test_invitation_id (一對一 → test_invitation.id)
├── test_project_id
├── raw_data (JSONB)
├── trait_results (JSONB)
├── category_results (JSONB)
├── score_value
└── crawl_status
```

## 修正方案

### 方案 1: 修正 SQL 查詢（推薦）

修改 BackEnd 的 SQL 查詢以匹配實際的數據庫結構：

```python
# 修正前
sql = """
    SELECT ip.id, ip.name, ip.email, ip.phone
    FROM individual_profile ip
    LEFT JOIN individual_test_result itr ON ip.id = itr.individual_id
"""

# 修正後
sql = """
    SELECT
        cu.id,
        cu.username as name,
        cu.email,
        (SELECT phone FROM individual_profile WHERE user_id = cu.id LIMIT 1) as phone,
        cu.date_joined as created_at,
        itr.trait_results
    FROM core_user cu
    LEFT JOIN individual_test_result itr ON cu.id = itr.user_id
    WHERE cu.user_type = 'individual'
      AND itr.trait_results IS NOT NULL
"""
```

### 方案 2: 支持兩種數據源

同時支持個人測驗結果和企業邀請結果：

```python
# 查詢個人測驗結果
individual_sql = """
    SELECT DISTINCT ON (cu.id)
        cu.id,
        cu.username as name,
        cu.email,
        itr.trait_results,
        'individual' as source
    FROM core_user cu
    JOIN individual_test_result itr ON cu.id = itr.user_id
    WHERE cu.user_type = 'individual'
      AND itr.result_status = 'completed'
"""

# 查詢企業邀請結果
enterprise_sql = """
    SELECT DISTINCT ON (ti.invitee_id)
        ti.invitee_id as id,
        tie.name,
        tie.email,
        tpr.trait_results,
        'enterprise' as source
    FROM test_invitation ti
    JOIN test_invitee tie ON ti.invitee_id = tie.id
    JOIN test_project_result tpr ON ti.id = tpr.test_invitation_id
    WHERE ti.status = 'completed'
      AND tpr.crawl_status = 'completed'
"""

# 合併結果
combined_sql = f"""
    ({individual_sql})
    UNION ALL
    ({enterprise_sql})
    ORDER BY id
"""
```

### 方案 3: 創建數據庫視圖（最佳）

創建一個統一的視圖來簡化查詢：

```sql
CREATE OR REPLACE VIEW talent_search_view AS
SELECT
    cu.id,
    cu.username as name,
    cu.email,
    ip.phone,
    cu.date_joined as created_at,
    itr.trait_results,
    itr.category_results,
    itr.score_value,
    itr.test_completion_date,
    'individual' as source_type
FROM core_user cu
LEFT JOIN individual_profile ip ON cu.id = ip.user_id
LEFT JOIN individual_test_result itr ON cu.id = itr.user_id
WHERE cu.user_type = 'individual'

UNION ALL

SELECT
    tie.id,
    tie.name,
    tie.email,
    tie.phone,
    ti.invited_at as created_at,
    tpr.trait_results,
    tpr.category_results,
    tpr.score_value,
    ti.completed_at as test_completion_date,
    'enterprise' as source_type
FROM test_invitee tie
JOIN test_invitation ti ON tie.id = ti.invitee_id
JOIN test_project_result tpr ON ti.id = tpr.test_invitation_id
WHERE ti.status = 'completed'
  AND tpr.crawl_status = 'completed';
```

然後在 BackEnd 中使用：

```python
sql = """
    SELECT id, name, email, phone, trait_results, category_results
    FROM talent_search_view
    WHERE trait_results IS NOT NULL
"""
```

## trait_results 數據結構

### 實際的 JSON 結構

```json
{
  "communication": {
    "chinese_name": "溝通能力",
    "score": 82.5,
    "percentile": 75,
    "level": "高"
  },
  "leadership": {
    "chinese_name": "領導力",
    "score": 78.0,
    "percentile": 68,
    "level": "中等"
  }
}
```

### SQL 查詢特質分數

```sql
-- 查詢特定特質分數
SELECT
    cu.username,
    (trait_results->>'communication')::jsonb->>'score' as communication_score
FROM core_user cu
JOIN individual_test_result itr ON cu.id = itr.user_id
WHERE (trait_results->>'communication')::jsonb->>'score' IS NOT NULL;

-- 查詢分數大於某值的候選人
SELECT cu.username
FROM core_user cu
JOIN individual_test_result itr ON cu.id = itr.user_id
WHERE ((trait_results->>'communication')::jsonb->>'score')::float >= 80;
```

## 修正後的搜索邏輯

### 1. 基礎查詢

```python
def search_candidates_fixed(self, parsed_query: Dict) -> List[Dict]:
    """修正後的候選人搜索"""
    cursor = self.conn.cursor()

    base_sql = """
        SELECT DISTINCT ON (cu.id)
            cu.id,
            cu.username as name,
            cu.email,
            (SELECT phone FROM individual_profile WHERE user_id = cu.id LIMIT 1) as phone,
            cu.date_joined as created_at,
            itr.trait_results,
            itr.category_results,
            itr.score_value
        FROM core_user cu
        JOIN individual_test_result itr ON cu.id = itr.user_id
        WHERE cu.username IS NOT NULL
          AND itr.trait_results IS NOT NULL
          AND itr.result_status = 'completed'
    """

    # 添加特質條件
    sql_conditions = parsed_query.get('sql_conditions', [])
    if sql_conditions:
        where_clause = " AND (" + " OR ".join(sql_conditions) + ")"
        base_sql += where_clause

    base_sql += """
        ORDER BY cu.id, itr.test_completion_date DESC NULLS LAST
        LIMIT 50;
    """

    cursor.execute(base_sql)
    results = cursor.fetchall()

    candidates = []
    for row in results:
        candidates.append({
            'id': row[0],
            'name': row[1],
            'email': row[2],
            'phone': row[3],
            'created_at': row[4].isoformat() if row[4] else None,
            'trait_results': row[5] or {},
            'category_results': row[6] or {},
            'score_value': row[7]
        })

    cursor.close()
    return candidates
```

### 2. 特質分數查詢

```python
def generate_trait_condition(self, trait_name: str, min_score: int) -> str:
    """生成特質查詢條件"""
    # 支持多種查詢方式
    conditions = [
        # 方式1: 直接查詢 trait_results
        f"((trait_results->>'{trait_name}')::jsonb->>'score')::float >= {min_score}",

        # 方式2: 查詢中文名稱
        f"EXISTS (SELECT 1 FROM jsonb_each(trait_results) WHERE (value->>'chinese_name' = '{trait_name}' AND (value->>'score')::float >= {min_score}))"
    ]

    return f"({' OR '.join(conditions)})"
```

### 3. 匹配分數計算

```python
def calculate_match_score_fixed(self, candidate: Dict, parsed_query: Dict) -> float:
    """修正後的匹配分數計算"""
    matched_traits = parsed_query.get('matched_traits', [])
    trait_results = candidate.get('trait_results', {})

    if not trait_results or not matched_traits:
        return 0.5

    total_score = 0
    total_weight = 0
    matched_count = 0

    for trait in matched_traits:
        trait_name = trait.get('system_name') or trait.get('chinese_name')
        min_score = trait.get('min_score', 0)
        weight = trait.get('weight', 1.0)

        # 查找特質分數
        actual_score = None

        # 嘗試直接匹配
        if trait_name in trait_results:
            trait_data = trait_results[trait_name]
            if isinstance(trait_data, dict):
                actual_score = trait_data.get('score', 0)

        # 嘗試通過中文名稱匹配
        if actual_score is None:
            for key, value in trait_results.items():
                if isinstance(value, dict):
                    if value.get('chinese_name') == trait_name:
                        actual_score = value.get('score', 0)
                        break

        if actual_score is not None:
            # 計算加權分數
            if actual_score >= min_score:
                total_score += actual_score * weight
            else:
                total_score += actual_score * weight * 0.5

            total_weight += 100 * weight
            matched_count += 1

    if total_weight > 0:
        base_score = total_score / total_weight
        coverage_ratio = matched_count / len(matched_traits)
        coverage_bonus = coverage_ratio * 0.1
        return min(base_score + coverage_bonus, 1.0)

    return 0.3
```

## 實施步驟

1. **備份現有代碼**

   ```bash
   cp BackEnd/talent_search_api.py BackEnd/talent_search_api_backup.py
   ```

2. **更新 SQL 查詢**

   - 修改所有使用 `individual_profile` 的查詢
   - 改用 `core_user` + `individual_test_result`

3. **測試查詢**

   ```python
   python tests/test_database_queries.py
   ```

4. **更新 LLM Prompt**

   - 確保 LLM 生成的 SQL 條件使用正確的欄位名稱
   - 更新特質查詢的 JSONB 語法

5. **驗證結果**
   - 測試搜索功能
   - 驗證匹配分數計算
   - 檢查返回的數據格式

## 注意事項

1. **JSONB 查詢性能**

   - 為 `trait_results` 創建 GIN 索引

   ```sql
   CREATE INDEX idx_trait_results_gin ON individual_test_result USING GIN (trait_results);
   ```

2. **NULL 值處理**

   - 確保處理 `trait_results` 為 NULL 的情況
   - 使用 `COALESCE` 或 `IS NOT NULL` 過濾

3. **數據一致性**

   - 確保 `result_status = 'completed'` 才查詢
   - 檢查 `test_completion_date` 是否存在

4. **權限控制**
   - 個人用戶只能看到自己的結果
   - 企業用戶只能看到自己邀請的候選人

---

**文檔版本**: 1.0  
**最後更新**: 2025-11-15
