# 多用戶多輪對話連貫性保障機制

## 概述

本系統通過 **會話隔離（Session Isolation）** 和 **上下文管理（Context Management）** 機制，確保多個用戶同時使用時，各自的對話保持獨立且連貫。

---

## 核心機制

### 1. 會話 ID（Session ID）

每個用戶在開始對話時，會獲得一個唯一的會話 ID：

```javascript
// frontend/src/stores/talent.js
function generateSessionId() {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
```

**特點**：

- 基於時間戳 + 隨機字符串，確保全局唯一
- 前端生成並持久化在 Pinia Store 中
- 每次 API 請求都會攜帶此 Session ID

---

### 2. 會話上下文（ConversationContext）

每個會話維護獨立的上下文狀態：

```python
# BackEnd/conversation_manager.py
class ConversationContext:
    def __init__(self, session_id: str):
        self.session_id = session_id
        self.messages: List[Dict[str, Any]] = []          # 對話歷史
        self.current_candidate: Optional[Dict] = None     # 當前關注的候選人
        self.current_candidates: List[Dict] = []          # 當前候選人列表
        self.last_intent: Optional[str] = None            # 最後的意圖
        self.last_query: Optional[str] = None             # 最後的查詢
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
```

**保存的資訊**：

- 對話歷史（用戶和助手的所有訊息）
- 當前關注的候選人（單一候選人）
- 當前候選人列表（搜索結果）
- 最後的意圖和查詢
- 時間戳

---

### 3. 會話管理器（ConversationManager）

全局單例管理所有會話：

```python
class ConversationManager:
    def __init__(self):
        self.sessions: Dict[str, ConversationContext] = {}

    def get_or_create_session(self, session_id: str) -> ConversationContext:
        if session_id not in self.sessions:
            self.sessions[session_id] = ConversationContext(session_id)
        return self.sessions[session_id]
```

**工作原理**：

- 使用 `Dict[session_id, ConversationContext]` 存儲所有會話
- 每個 Session ID 對應一個獨立的上下文
- 不同用戶的會話完全隔離，互不干擾

---

## 多用戶隔離保障

### 場景示例

**用戶 A**：

```
Session ID: session_1700000001_abc123
查詢 1: "找一個溝通能力強的人"
結果: 3 位候選人
查詢 2: "從這些人中找出有領導力的"
結果: 從 3 位中篩選出 1 位
```

**用戶 B**（同時使用）：

```
Session ID: session_1700000002_xyz789
查詢 1: "找一個創造力強的設計師"
結果: 5 位候選人
查詢 2: "從這些人中找出內向型的"
結果: 從 5 位中篩選出 2 位
```

**保障機制**：

1. 用戶 A 和用戶 B 有不同的 Session ID
2. 後端維護兩個獨立的 `ConversationContext`
3. 用戶 A 的 "從這些人中" 只會從他自己的 3 位候選人中篩選
4. 用戶 B 的 "從這些人中" 只會從他自己的 5 位候選人中篩選
5. 兩者的對話歷史、候選人列表完全獨立

---

## 上下文感知搜索

### 意圖分析

系統會根據上下文判斷用戶的真實意圖：

```python
def analyze_context_intent(self, context: ConversationContext, current_query: str):
    # 檢查是否是從當前結果中篩選
    if context.current_candidates and len(context.current_candidates) > 0:
        filter_from_current_keywords = ['從裡面', '從這些', '從中', '其中', '再篩選']
        is_filter_from_current = any(kw in current_query for kw in filter_from_current_keywords)

        if is_filter_from_current:
            return {
                'is_follow_up': True,
                'follow_up_intent': 'filter_from_current',
                'target_candidates': context.current_candidates,
                'scope': 'current'
            }
```

**支援的意圖類型**：

- `filter_from_current`: 從當前結果中篩選
- `filter_new`: 新增篩選條件
- `exclude`: 排除某些候選人
- `new_search`: 重新搜索（清空之前的結果）
- `compare`: 比較候選人
- `describe`: 描述候選人
- `interview`: 面試問題

---

## 漸進式篩選實現

### 工作流程

1. **第一輪搜索**：

   ```
   用戶: "找溝通能力強的人"
   系統: 搜索全部候選人 → 返回 10 位
   上下文: current_candidates = [10 位候選人]
   ```

2. **第二輪篩選**：

   ```
   用戶: "從這些人中找出有領導力的"
   系統: 檢測到 "從這些人中" → 漸進式篩選模式
   系統: 只在 current_candidates (10 位) 中篩選
   系統: 返回 3 位符合條件的候選人
   上下文: current_candidates = [3 位候選人]
   ```

3. **第三輪篩選**：
   ```
   用戶: "再篩選出內向型的"
   系統: 檢測到 "再篩選" → 漸進式篩選模式
   系統: 只在 current_candidates (3 位) 中篩選
   系統: 返回 1 位符合條件的候選人
   上下文: current_candidates = [1 位候選人]
   ```

### 核心代碼

```python
# 處理從當前結果中篩選
if follow_up_intent == 'filter_from_current' and scope == 'current':
    current_candidates = context.current_candidates

    if current_candidates:
        # 使用 LLM 分析新的篩選條件
        llm_result = await engine.llm_service.analyze_query(query_text)

        if llm_result['success']:
            matched_traits = llm_result['analysis'].get('matched_traits', [])

            # 從當前候選人中篩選
            filtered_candidates = engine.filter_candidates_by_traits(
                current_candidates,  # 只在這些候選人中篩選
                matched_traits
            )
```

---

## API 請求流程

### 前端請求

```javascript
// frontend/src/api/talent.js
async searchTalents(query, sessionId) {
  const response = await axios.post('/api/search', {
    query: query,
    session_id: sessionId  // 攜帶會話 ID
  });
  return response.data;
}
```

### 後端處理

```python
@app.post("/api/search")
async def search_talents(query: SearchQuery):
    session_id = query.session_id or "default"

    # 1. 獲取或創建會話上下文
    context = conversation_manager.get_or_create_session(session_id)

    # 2. 添加用戶訊息到對話歷史
    context.add_message('user', query_text)

    # 3. 分析上下文意圖
    context_analysis = conversation_manager.analyze_context_intent(context, query_text)

    # 4. 根據意圖執行相應操作
    if context_analysis.get('follow_up_intent') == 'filter_from_current':
        # 從當前候選人中篩選
        filtered_candidates = engine.filter_candidates_by_traits(
            context.current_candidates,
            matched_traits
        )

    # 5. 更新會話上下文
    context.set_current_candidates(filtered_candidates)

    # 6. 添加助手回應到對話歷史
    context.add_message('assistant', understanding)
```

---

## 會話生命週期管理

### 會話創建

```javascript
// 前端初始化時自動生成
const sessionId = ref(generateSessionId());
```

### 會話重置

```javascript
// 用戶點擊 "新對話" 按鈕
function resetSession() {
  sessionId.value = generateSessionId(); // 生成新的 Session ID
  messages.value = [];
  candidates.value = [];
  filterHistory.value = [];
}
```

### 會話清除（後端）

```python
@app.delete("/api/session/{session_id}")
async def clear_session(session_id: str):
    if session_id in conversation_manager.sessions:
        conversation_manager.sessions[session_id].clear()
```

---

## 並發安全性

### 當前實現

- 使用 Python 字典存儲會話（`Dict[str, ConversationContext]`）
- FastAPI 的異步處理確保請求隔離
- 每個請求處理獨立的會話上下文

### 潛在問題與解決方案

**問題 1**: 內存中的會話數據在服務重啟後丟失

**解決方案**:

- 短期：可接受（用戶刷新頁面會生成新 Session ID）
- 長期：使用 Redis 或資料庫持久化會話

**問題 2**: 高並發下的會話數據競爭

**解決方案**:

- 當前：FastAPI 的異步機制已提供基本保護
- 進階：使用 `asyncio.Lock` 或 Redis 分布式鎖

---

## 測試驗證

### 測試場景 1：多用戶隔離

```python
# 模擬用戶 A
session_a = "session_a"
response_a1 = await search_talents({"query": "找溝通能力強的人", "session_id": session_a})
response_a2 = await search_talents({"query": "從這些人中找領導力強的", "session_id": session_a})

# 模擬用戶 B
session_b = "session_b"
response_b1 = await search_talents({"query": "找創造力強的設計師", "session_id": session_b})
response_b2 = await search_talents({"query": "從這些人中找內向型的", "session_id": session_b})

# 驗證
assert response_a2['candidates'] 是從 response_a1['candidates'] 中篩選
assert response_b2['candidates'] 是從 response_b1['candidates'] 中篩選
assert response_a2['candidates'] != response_b2['candidates']
```

### 測試場景 2：上下文連貫性

```python
session_id = "test_session"

# 第一輪
r1 = await search_talents({"query": "找溝通能力強的人", "session_id": session_id})
assert len(r1['candidates']) == 10

# 第二輪（從當前結果篩選）
r2 = await search_talents({"query": "從這些人中找領導力強的", "session_id": session_id})
assert len(r2['candidates']) <= 10
assert all(c in r1['candidates'] for c in r2['candidates'])

# 第三輪（繼續篩選）
r3 = await search_talents({"query": "再篩選出內向型的", "session_id": session_id})
assert len(r3['candidates']) <= len(r2['candidates'])
assert all(c in r2['candidates'] for c in r3['candidates'])
```

---

## 總結

### 核心保障機制

1. **會話隔離**：每個用戶有唯一的 Session ID
2. **上下文管理**：每個會話維護獨立的對話歷史和候選人列表
3. **意圖識別**：智能判斷是新搜索還是從當前結果篩選
4. **漸進式篩選**：確保 "從這些人中" 只在當前會話的候選人中操作

### 優勢

- ✅ 多用戶完全隔離，互不干擾
- ✅ 支援複雜的多輪對話
- ✅ 上下文感知，理解用戶真實意圖
- ✅ 漸進式篩選，結果越來越精準

### 未來優化方向

1. **持久化**：使用 Redis 存儲會話，支援服務重啟
2. **過期清理**：自動清理長時間未使用的會話
3. **並發鎖**：使用分布式鎖保護高並發場景
4. **會話恢復**：支援用戶刷新頁面後恢復會話
